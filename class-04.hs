{-
Все задачи в этом задании должны решаться исключительно с помощью свёрток.
Явная рекурсия не допускается. Если в решении в качестве вспомогательной
требуется стандартная функция обработки списков (помимо fold*, scan*), она
также должна реализовываться свёрткой.
Каждое решение должно сопровождаться тремя различными тестовыми примерами, которые при запуске
возвращают True, например:
f = undefined -- решение
f_test1 = f undefined == undefined -- тест 1
f_test2 = f undefined == undefined -- тест 2
f_test3 = f undefined == undefined -- тест 3
-}

import Data.List

{- 1. Простейшие функции обработки списков -}

-- a) Найти сумму чётных элементов списка с целочисленными элементами.
f1a :: [Int] -> Int
f1a = foldl (\acc x -> if even x then acc + x else acc) 0

f1a_t1 = f1a [1, 3] == 0       -- тест 1
f1a_t2 = f1a [1, 2, 3] == 2    -- тест 2
f1a_t3 = f1a [1, 2, 3, 4] == 6 -- тест 3

-- b) Найти сумму и произведение элементов списка вещественных чисел.
f1b :: Floating a => [a] -> (a, a)
f1b = foldl (\(s, p) x -> (s + x, p * x)) (0, 1.0)

f1b_t1 = f1b [] == (0, 1)        -- тест 1
f1b_t2 = f1b [0, 1] == (1, 0)    -- тест 2
f1b_t3 = f1b [1, 2, 4] == (7, 8) -- тест 3

-- с) Найти среднее арифметическое элементов списка вещественных чисел (функцией length пользоваться нельзя,
-- решение должно выполняться в один проход).
f1c :: Floating a => [a] -> a
f1c [] = 0.0
f1c xs = (fst sumc) / (snd sumc)
  where sumc = foldl (\(s, c) x -> (s + x, c + 1)) (0, 0) xs

f1с_t1 = f1b [] == 0             -- тест 1
f1с_t2 = f1b [0, 1] == 0.5       -- тест 2
f1с_t3 = f1b [1, 2, 3] == 6      -- тест 3

-- d) Найти минимальный элемент списка.
f1d :: (Ord a, Floating a) => [a] -> a
f1d = foldl1 (\acc x -> min acc x)

f1d_t1 = f1d [-1, 0, 1] == -1    -- тест 1
f1d_t2 = f1d [1, 2, 3] == 1      -- тест 2
f1d_t3 = f1d [10, 5] == 5        -- тест 3

-- e) Найти наименьший нечётный элемент списка с целочисленными значениями (дополнительным параметром
-- функции должно быть значение, возвращаемое по умолчанию).
f1e :: [Int] -> Int -> Int
f1e xs def = foldl (\acc x -> if odd x then (if acc == def || x < acc then x else acc) else acc) def xs

f1e_t1 = f1e [1, 2] 0 == 1       -- тест 1
f1e_t2 = f1e [2, 4] 0 == 0       -- тест 2
f1e_t3 = f1e [3, 6, 7] 0 == 3    -- тест 3

{-
2. Свёртки, формирующие списки
-}

-- a) Сформировать список, содержащий каждый второй элемент исходного.
f2a :: Num a => [a] -> [a]
f2a = fst . foldl (\(dst, k) x -> if odd k then (dst ++ [x], k + 1) else (dst, k + 1)) ([], 0)

f2a_t1 = f2a [] == []                       -- тест 1
f2a_t2 = f2a [1] == []                      -- тест 2
f2a_t3 = f2a [1, 2, 3, 4] == [2, 4]         -- тест 3

-- b) Сформировать список, содержащий первые n элементов исходного.
f2b :: Num a => [a] -> Int -> [a]
f2b xs n = take n $ foldl (\acc x -> acc ++ [x]) [] xs

f2b_t1 = f2b [] 1 == []                     -- тест 1
f2b_t2 = f2b [1] 2 == [1]                   -- тест 2
f2b_t3 = f2b [1, 2, 3, 4, 5] 3 == [1, 2, 3] -- тест 3

-- c) Сформировать список, содержащий последние n элементов исходного.
f2c :: Num a => [a] -> Int -> [a]
f2c xs n = reverse $ take n $ foldr (\x acc -> acc ++ [x]) [] xs

f2c_t1 = f2c [] 1 == []                     -- тест 1
f2c_t2 = f2c [1] 2 == [1]                   -- тест 2
f2c_t3 = f2c [1, 2, 3, 4, 5] 3 == [3, 4, 5] -- тест 3

-- d) Сформировать список, содержащий все элементы исходного списка, большие левого соседа.
f2d :: (Num a, Ord a) => [a] -> [a]
f2d xs = fst $ foldl (\(dst, lel) x -> if x > lel then (dst ++ [x], x) else (dst, x)) ([], head xs) xs

f2d_test1 = f2d [3, 2, 1] == []             -- тест 1
f2d_test2 = f2d [1, 2, 3] == [2, 3]         -- тест 2
f2d_test3 = f2d [1, 4, 2, 5, 3] == [4, 5]   -- тест 3

-- e) Сформировать список, содержащий все локальные минимумы исходного списка.
f2e :: (Num a, Ord a) => [a] -> [a]
f2e xs = result
where func (acc, pp, p) x
  | p > pp && p > x = (acc ++ [p], p, x)
  | otherwise = (acc, p, x)
(result, _, _) = foldl func ([], head xs, head xs) xs

f2e_t1 = f2e [1, 2, 3] == []                -- тест 1
f2e_t2 = f2e [1, 3, 2] == [3]               -- тест 2
f2e_t3 = f2e [1, 4, 2, 5, 3] == [4, 5]      -- тест 3

-- f) Дана строка, содержащая слова, разделённые одним или несколькими пробелами. Сформировать
-- список слов этой строки.
f2f :: String -> [String]
f2f xs = res : ls
where 
(ls, res) = foldr func ([], []) xs
func x (dst, cur)
  | fromEnum x == 32 = (cur : dst, []) 
  | otherwise = (dst, x : cur)

f2f_t1 = f2f "" == [""]                      -- тест 1
f2f_t2 = f2f "abc" == ["abc"]                -- тест 2
f2f_t3 = f2f "abc 123" == ["abc", "123"]     -- тест 3

-- g) Разбить список на непересекающиеся подсписки длиной n элементов.
f2g :: Eq a => [a] -> Int -> [[a]]
f2g _ 0 = []
f2g xs n = ls ++ [res]
where
(ls, res) = foldl func ([], []) xs
func (dst, cur) x
  | length cur < n = (dst, cur ++ [x]) 
  | otherwise = (dst ++ [cur], [x])

f2g_t1 = f2g [1, 2, 3] 0 == []                        -- тест 1
f2g_t2 = f2g [1, 2, 3] 2 == [[1, 2], [3]]             -- тест 2
f2g_t3 = f2g [1, 2, 3, 4, 5] 3 == [[1, 2, 3], [4, 5]] -- тест 3

-- h) Разбить список на подсписки длиной n элементов с перекрывающейся частью в k элементов (k < n).
f2h :: Eq a => [a] -> Int -> Int -> [[a]]
f2h xs n k = foldl foldF [] (zip xs [0, 1 ..])
where
foldF acc (x, ind)
  | ind `mod` (n - k) == 0 = map (mapF x) (acc++[[]])
  | otherwise = map (mapF x) acc
mapF x ys
  | length ys == n = ys
  | otherwise = ys ++ [x]

f2h_t1 = f2h [1, 2, 3, 4, 5] 4 1 == [[1, 2, 3, 4], [4, 5]]                         -- тест 1
f2h_t2 = f2h [1, 2, 3, 4, 5] 4 2 == [[1, 2, 3, 4], [3, 4, 5], [5]]                 -- тест 2
f2h_t3 = f2h [1, 2, 3, 4, 5] 3 2 == [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5], [5]] -- тест 3

-- k) Сформировать список, содержащий все начальные элементы списка, удовлетворяющие заданному предикату.
f2k :: Eq a => [a] -> (a -> Bool) -> [a]
f2k xs pred = fst $ foldl func ([], True) xs
where
func (dst, flag) x
  | flag && pred x = (dst++[x], flag && pred x)
  | otherwise = (dst, False)

f2k_t1 = f2k [1, 2] (> 2) == []                 -- тест 1
f2k_t2 = f2k [1, 2, 3, 2] (== 2) == [2]         -- тест 2
f2k_t3 = f2k [1, 2, 3, 4, 5] (< 4) == [1, 2, 3] -- тест 3

-- l) Повторить каждый элемент списка заданное количество раз.
f2l :: Eq a => [a] -> Int -> [a]
f2l xs n = foldl (\acc x -> acc ++ (replicate n x)) [] xs

f2l_t1 = f2l [1, 2, 3] 0 == []                 -- тест 1
f2l_t2 = f2l [1, 2, 3] 1 == [1, 2, 3]          -- тест 2
f2l_t3 = f2l [1, 2, 3] 2 == [1, 1, 2, 2, 3, 3] -- тест 3


-- m) Удалить из списка повторяющиеся подряд идущие элементы.
f2m :: (Eq a, Integral a) => [a] -> [a]
f2m xs = reverse . foldl (\acc x -> if x == head acc then acc else x : acc) [head xs] $ tail xs

f2m_t1 = f2m [1, 2] == [1, 2]             -- тест 1
f2m_t2 = f2m [1, 2, 2, 3] == [1, 2, 3]    -- тест 2
f2m_t3 = f2m [1, 1, 2, 3, 3] == [1, 2, 3] -- тест 3

-- n) Даны два списка одинаковой длины. Сформировать список, состоящий из результатов применения
-- заданной функции двух аргументов к соответствующим элементам исходных списков.
f2n :: (Eq a, Eq b, Eq c) => (a -> b -> c) -> [a] -> [b] -> [c]
f2n func xs ys = foldr (\x acc -> func (fst x) (snd x) : acc) [] $ zip xs ys

f2n_t1 = f2n (+) [1, 2] [] == []             -- тест 1
f2n_t2 = f2n (+) [1, 2] [4, 6, 8] == [5, 8]  -- тест 2
f2n_t3 = f2n (*) [1, 2] [4, 6, 8] == [4, 12] -- тест 3

{-
3. Использование свёртки как носителя рекурсии (для запуска свёртки можно использовать список типа [1..n]).
-}

-- a) Найти сумму чисел от a до b.
f3a :: (Num a, Enum a) => a -> a -> a
f3a a b = foldl (\ acc x -> x + acc) 0 [a..b]

f3a_t1 = f3a 1 3 == 6            -- тест 1
f3a_t2 = f3a 3 1 == 0            -- тест 2
f3a_t3 = f3a 1 15 == sum [1..15] -- тест 3

-- b) Найти сумму факториалов чисел от a до b (повторные вычисления факториалов не допускаются).
f3b :: (Enum a, Num a, Eq a) => a -> a -> a
f3b a b = snd $ foldl foldFunc (fact (a - 1), 0) [a..b]
where
foldFunc (p, s) x = (p * x, p * x + s)
fact 0 = 1
fact x = x * fact (x - 1)

f3b_t1 = f3b 3 1 == 0                             -- тест 1
f3b_t2 = f3b 1 3 == 9                             -- тест 2
f3b_t3 = f3b 1 15 == sum [f3b n n | n <- [1..15]] -- тест 3

-- с) Сформировать список из первых n чисел Фибоначчи.
f3c n = take n fib
fib = 0 : scanl (+) 1 fib 

f3c_t1 = f3c 3 == [0, 1, 1]                          -- тест 1
f3c_t3 = f3c 5 == [0, 1, 1, 2, 3]                    -- тест 1
f3c_t2 = f3c 10 == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] -- тест 1

-- d) Пользуясь рядом Тейлора, вычислить значение синуса заданного числа x (использовать
-- n слагаемых).
f3d :: Floating a => a -> Integer -> a
f3d x n = fst $ foldl func (x, x) [fromInteger (2 * k - 1) | k <- [2..n]]
where 
func (range, cur) k = (range - cur*x*x/(k*(k - 1)), -cur*x*x/(k*(k - 1)))

f3d_t1 = f3d 0 1 == 0                                 -- тест 1
f3d_t2 = abs (f3d (pi / 2) 10 - 1) < 0.0001           -- тест 2
f3d_t3 = abs (f3d (pi / 4) 10 - sqrt(2) / 2) < 0.0001 -- тест 3

-- e) Проверить, является ли заданное целое число простым.
f3e :: Integral a => a -> Bool
f3e x = foldl (\ acc n -> (x `mod` n /= 0) && acc) True [2..(x - 1)]

f3e_t1 = f3e 2 == True  -- тест 1
f3e_t2 = f3e 8 == False -- тест 2
f3e_t3 = f3e 17 == True -- тест 3

{-
4. Решить задачу о поиске пути с максимальной суммой в треугольнике (см. лекцию 3) при условии,
что необходимо дополнительно найти сам путь (к примеру, в виде закодированных направлений спуска:
0 - влево, 1 - вправо). В решении допускается использование любых стандартных функций.
-}
downstep :: [Int] -> [Int] -> [Int]
downstep upper lower = zipWith (+) lower $ zipWith max (0 : upper) (upper ++ [0])
f4 :: [[Int]] -> Int
f4 = maximum . foldl1 downstep

f4_t1 = f4 [[3], [7, 4], [2, 4, 6], [8, 5, 9, 3]] == 23                  -- тест 1
f4_t2 = f4 [[55], [94, 48], [95, 30, 96], [77, 71, 26, 67]] == 321       -- тест 2
f4_t3 = f4 [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] == 30 -- тест 3

{-
5. Пусть числовые матрицы представлены списками строк. Реализовать следующие функции:
-}

-- 1) транспонирование матрицы;
f51 :: [[Int]] -> [[Int]]
f51 = foldr (zipWith (:)) (repeat [])

f51_t1 = f51 [[1, 2, 3]] == [[1], [2], [3]]                               -- тест 1
f51_t2 = f51 [[1], [2], [3]] == [[1, 2, 3]]                               -- тест 2
f51_t3 = f51 [[1,3,4], [2,6,8], [4,9,16]] == [[1,2,4], [3,6,9], [4,8,16]] -- тест 3

-- 2) сумма двух матриц;
f52 :: [[Int]] -> [[Int]] -> [[Int]]
f52 = zipWith (zipWith (+))

f52_t1 = f52 [[1]] [[2]] == [[3]]                                                 -- тест 1
f52_t2 = f52 [[1, 2]] [[3, 4]] == [[4, 6]]                                        -- тест 2
f52_t3 = f52 [[1,2], [3,4], [5,6]] [[6,5], [4,3], [2,1]] == [[7,7], [7,7], [7,7]] -- тест 3

-- 3) произведение двух матриц.

{-
6. Реализовать левую свёртку, пользуясь правой. Проанализировать поведение собственной реализации
на бесконечных списках и сравнить его с поведением оригинальной foldl.
-}
f6 :: (a -> b -> a) -> a -> [b] -> a
f6 f a bs = foldr (\b g x -> g (f x b)) id bs a
-- не работает на бесконечных списках, "обратное неверно" (имеется в виду реализация, см. haskell.org/haskellwiki)
