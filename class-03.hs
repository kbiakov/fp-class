{-
Явная рекурсия в решениях хотя и допускается, но не приветствуется. Старайтесь обходиться стандартными
функциями, используя при этом создание функций «на лету». Пытайтесь максимально упростить уже написанные
решения, применяя подходящие функции из модуля Data.List и любых других модулей. Перед выполнением заданий
изучите примеры из лекции по функциям высшего порядка.
-}

import Data.Char
import Data.List

{-
1. Простейшие задачи на применение функций map и filter.
1.1 Преобразовать данный список целых чисел следующим образом:
-}

-- a) увеличить все его элементы в два раза;
f11a :: Integral a => [a] -> [a]
f11a = map (*2)
-- b) увеличить все его элементы с четными значениями в два раза;
f11b :: Integral a => [a] -> [a]
f11b = map (\x -> if even x then 2*x else x)
-- с) обнулить все его элементы с нечетными значениями;
f11c :: Integral a => [a] -> [a]
f11c = map (\x -> if odd x then 0 else x)
-- d) удалить из него элементы, большие заданного числа k;
f11d :: Integral a => a -> [a] -> [a]
f11d k = filter (\x -> x <= k)
-- e) отфильтровать его, оставив в списке только отрицательные числа;
f11e :: Integral a => [a] -> [a]
f11e = filter (\x -> x < 0)
-- f) удалить из него все положительные чётные числа.
f11f :: Integral a => [a] -> [a]
f11f = filter (\x -> x < 0 || odd x)

{-
1.2 Дан список декартовых координат точек на плоскости (пар вещественных чисел).
Преобразовать его следующим образом:
-}

type Point = (Double, Double)

-- a) отфильтровать список так, чтобы в нём остались точки из заданной координатной четверти;
f12a :: Integral a => a -> [Point] -> [Point]
f12a n = filter(\(x,y) -> 
  | n == 1 = x >= 0 && y >= 0
  | n == 2 = x < 0 && y >= 0
  | n == 3 = x < 0 && y < 0
  | n == 4 = x >= 0 && y < 0)
-- b) преобразовать декартовы координаты в полярные.
f12b :: [Point] -> [Point]
f12b = map(\(x, y) -> (sqrt x^2 + y^2, atan y/x))

{-
1.3 Дан список слов.
-}

-- a) Преобразовать все слова к верхнему регистру.
f13a :: [String] -> [String]
f13a = map (map toUpper)
-- b) Извлечь из него подсписок слов заданной длины.
f13b :: Int -> [String] -> [String]
f13b n = filter (\x -> length x == n)
-- c) Извлечь из него подсписок слов, начинающихся с заданной буквы.
f13c :: Char -> [String] -> [String]
f13c ch = filter (\x -> head x == ch)

{-
2. Формирование числовых последовательностей (iterate).
-}

-- a) Список натуральных чисел, начиная с 0.
f2a :: [Integer]
f2a = iterate (+ 1) 0
-- b) Список чётных чисел.
f2b :: [Integer]
f2b = iterate (+ 2) 2
-- c) Список элементов последовательности: a0=1, an=(1+an-1)/2.
f2c :: [Double]
f2c = iterate (\x -> (1 + x - 1) / 2) 1
-- d) Список символов английского алфавита.
f2d :: [Char]
f2d = ['a'..'z'] ++ ['A'..'Z']
-- e) Список строк, представляющих n-значные двоичные числа.
f2e :: Int -> [String]
f2e n = map comp (filter (\x -> length x <= n) (map toBin (take (2^n) (iterate (+1) 0))))
  where comp = (\x -> (replicate (n - length x) '0') ++ x)
        toBin 0 = []
        toBin n 
        | n `mod` 2 ==0 = toBin (div k 2) ++ ['0']
        | otherwise     = toBin (div k 2) ++ ['1']

{-
3. Группировка списков.
-}

-- a) Дан список символов. Сгруппировать подряд идущие символы по принципу: цифры — не цифры — ...
f3a :: [Char] -> [[Char]]
f3a = groupBy (\x y -> (isDigit x && isDigit y) || ((not . isDigit) x && (not . isDigit) y))
-- b) Дан список пар вещественных чисел (координат точек на плоскости). Сгруппировать подряд идущие
-- координаты точек, лежащие в одной координатной четверти.
f3b :: [Point] -> [[Point]]
f3b = groupBy (\x y -> quar x == quart y)
  where quart (x, y)
    | x >= 0 && y >= 0 = 1
    | x < 0 && y >= 0 = 2
    | x < 0 && y < 0 = 3
    | x >= 0 && y < 0 = 4
-- c) Дан список и ненулевое натуральное число n. Разбить список на подсписки длиной n каждый.
-- Последний подсписок может содержать менее n элементов.
f3c :: [a] -> Int -> [[a]]
f3c l n = map (take n) $ takeWhile (not.null) $ iterate (drop n) l
-- d) Дан список и ненулевые натуральные числа n и m. Разбить список на перекрывающиеся подсписки
-- длиной n элементов со сдвигом относительно предыдущего подсписка на m элементов.
f3d :: [a] -> Int -> Int -> [[a]]
f3d l n m = map (take n) $ takeWhile (not.null) $ iterate (drop m) l
-- e) Дан список. Определить длину самого длинного подсписка, содержащего подряд идущие одинаковые элементы.
f3e :: Eq a => [a] -> Int
f3e = maximum . (map length) . group
-- Должно быть True
test_f3d = f3d [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

{-
4. Разные задачи.
-}

-- a) Дан текст в виде строки символов, содержащий среди прочего числовые данные. Посчитать количество
-- всех упоминающихся в тексте чисел.
f4a :: String -> Int
f4a str = length $ filter (\x -> isDigit x) str
-- b) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату, в указанном промежутке
-- (например: все чётные от 1 до 106).
fib = 0 : 1 : zipWith (+) fibs (tail fib)
f4b :: (Int -> Bool) -> Int -> Int -> Int
f4b p a b = sum $ filter p $ dropWhile (\x -> x < a) $ takeWhile (\x -> x < b) fib
-- c) Дана строка текста и число n. Сформировать список, содержащий n самых часто используемых
-- в строке символов.
f4c :: Int -> String -> String
f4c n = (take n) . (map head) . reverse . sortBy (\x y -> compare (length x) (length y)) . group . sort
-- d) Дан список чисел. Сформировать список локальных максимумов исходного списка. Локальным максимумом
-- называется элемент, больший своих соседей.
f4d :: Ord a => [a] -> [a]
f4d l = map (\(x:y:z:xs) -> y) $ filter (\(x:y:z:xs) -> y > x && y > z) $ filter (\xs -> length xs == 3) $ map (take 3) $ tails l
-- e) Дан список. Продублировать все его элементы.
f4e :: [a] -> [a]
f4e = concat . map (\x -> [x,x])
